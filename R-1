### 1-1 변수 이해하기

##########################################

# 데이터 형태 이해하기

# ▶ 변수를 생성하기 위해서는 대입연산자 (<-)를 사용하여 변수를 생성한다.

### 변수 삽입

3+4
x <- 10
y <- 10
z <- c(1,2,3,4,5)
z = c(1,2,3,4,5)

#c로 묶는게 백터형태. 하나는 스칼라여서 안 묶음. 여러개는 묶는데.

#생선된 변수 목록을 보여준다

# ls함수에서는 목록만 보여주며 변수의 유형 값 등을 확인 할 수 없다.

ls()

#ls.str함수는 생성된 변수 목록 뿐만 아니라 각 변수의 유형 및 값 등을 확인 할 수 있다.
ls.str()

> ls()
[1] "x" "y" "z"
#ls.str함수는 생성된 변수 목록 뿐만 아니라 각 변수의 유형 및 값 등을 확인 할 수 있다.
ls.str()
x :  num 10
y :  num 10
z :  num [1:5] 1 2 3 4 5

rm(list = ls()) #오브젝트 내의 모든 변수 삭제

### 변수 삭제

#하나 있을 때는 c 묶어도 안 묶어도 된대.

# ▶ 필요 없는 변수나 함수를 작업 공간에서 삭제하거나 내용을 완전히 삭제할 때 rm 함수를 사용한다

x <- 10
y <- 20
y=c(1,2,3)
z <- 30
ls() #생성된 변수 보기

rm(x) #x변수 삭제/ x다시 실행 불가능.그냥 다시 실행하면 덮어씌워짐.

#rm 많이 사용 안 함. 밑에 쓰면 덮어씌워지기에.
rm(list = ls()) #오브젝트 내의 모든 변수 삭제

### 벡터(Vector)

# ▶ 벡터란 한 개 이상의 원소로 구성된 자료구조로서 R의 자료 객체 중에서 가장 기본이 되는 자료 객채임

# ▶ 그리고 하나의 벡터의 원소는 한 가지 형태(mode)만이 가능

# 벡터 생성

v1 <- c(1,2,3) #숫자형 벡터 생성
v2 <- c("a", "b", "c") #문자형 벡터 생성
v3 <- c(T, F, T)
height <- c(160, 140, 155) #height 벡터 생성
#할당까지.드래그해서 실행시키면 나옴.

## 이건 왜 ????

my_variable <- c(10)
my_variable

rm(list = ls()) #오브젝트 내의 모든 변수 삭제

##########################################

### 1-2 함수 사용

##########################################

# 함수 사용

# 처음값:끝값 사용하기

# :은 사이의 수를 전부 갖고온다

c(1,2,3,4,5)
1:5
c(1:5)
1:10000

**#seq (시작값, 마지막값, 증가분 * length : 길이지정)**

기본값이 by라 안 써도 된다.

seq(1, 7, by=2) 

#seq(시작값, by=증가분, 조건지정)
seq(1, -1, by=-0.5)
seq(1,7,length=3)
seq(1,10,length=10)

> seq(1,7,length=3)
[1] 1 4 7
seq(1,10,length=10)
[1]  1  2  3  4  5  6  7  8  9 10

**#rep (반복할 값, 반복횟수 * each : 각각 * length : 길이만큼)**
#기본값이 times라서 안 써도 됩니다.

rep(c(1,2,3),3) #rep(a,b)는 a를 b만큼 반복
rep(1:3,3) #a:b는 a부터 b까지의 수

> rep(1:3,3)      #a:b는 a부터 b까지의 수
[1] 1 2 3 1 2 3 1 2 3

rep(c(4,2), times=2) # 반복 출력
rep(c(4,2), times=c(2,1)) # times 에 주어진 수 만큼 반복 #위치에 따라 반복. 4를 2번 2를 1번 반복
rep(c(4,2), length=20) ## 길이만큼 반복
rep(c(4,2), each=3) ## 각각 반복

#times전체반복 여러개 위치에 따라 반복, each는 전체를 각각 반복.

> rep(c(4,2), times=c(2,1)) # times 에 주어진 수 만큼 반복 #위치에 따라 반복. 4를 2번 2를 1번 반복
[1] 4 4 2
rep(c(4,2), length=20) ## 길이만큼 반복
[1] 4 2 4 2 4 2 4 2 4 2 4 2 4 2 4 2 4 2 4 2
rep(c(4,2), each=3) ## 각각 반복
[1] 4 4 4 2 2 2

**?rep** #rep에 대한 설명이 나온다고 합니다.

# 연습문제

1. 1-100까지 짝수를 2번씩 출력

a = c(seq(2,100,2))
rep(a,each=2)
rep(seq(2,100,2),each=2)

rep(seq(2,100,2),each=2) #best

2. 1-5까지 숫자만큼 반복

b = c(1:5)
rep(b, times=c(1,2,3,4,5))

rep(b,times=b) #mine에서 best

rep(b,b) #이것도 있다.
rep(1:5,1:5) #best

# rep, seq를 한번에 사용하는 문

##########################################

### 1-3 범주형 자료

##########################################

# 요인(범주형 자료)

#factor(obj, levels=변수값, labels=요인이름)
obj : 요인을 생성할 객체

#2PPT - 16

gender <- factor(c("MALE","FEMALE","MALE"))

gender

#levels: 중복된 값 제외한. 원재료.?

#levels 지정이 된다.(가능한 경우의 값) o,ab,a만 가지고 factor하면, 그것만. 단지 b형이 지금 없을 뿐.

blood <- factor(c("O","AB","A"),levels = c("A","B","AB","O"),labels=c("A형","B형","AB형","O형"))
blood

> blood
[1] O형  AB형 A형
Levels: A형 B형 AB형 O형

2-2. 요인(Factor)

---

요인은 범주형 데이터를 표현한다. 범주형 데이터란 데이터가 사전에 정해진 특정 유형으로만 분류되는 경우를 뜻한다.

```
> sex <- factor("m", c("m", "f"))
> sex
[1] m
Levels: m f
> levels(sex) <- c("male", "female")
> sex
[1] male
Levels: male female

sex=factor("m",c("m","f"),c("male","female"))

sex 변수를 출력해보면 값은 m이고 이 변수가 가질수 있는 수준은 m, f 중에 하나이다. 요인들이 가질 수 있는 값들을 수준(Level)이라고 한다. 만약 이 범주안에 없는 값(첫번째 인자)을 넣어주면 NA라고 뜬다. 요인은 명목형과 순서형으로 구분되는데, 명목형은 값들 간에 순서비교가 불가능하고, 순서형은 가능(ordered=TRUE)하다. 기본적으로 명목형이다.

- factor(값, levels, ordered=T 또는 F) 로 호출하면 요인을 반환한다. levels 인자를 생략하면 값으로부터 자동으로 레벨의 목록을 파악한다.
- nlevels(요인변수) : 범주의 수를 반환한다.
- levels(요인변수) : 범주목록을 반환한다.
- is.factor(객체) : 참거짓 확인
- ordered(값, levels) 로 호출하면 순서형 요인을 반환한다. 즉 actor(값, levels, ordered=T)와 같다.
- is.ordered(객체) : 참거짓 확인

출처:

[https://sjh836.tistory.com/112](https://sjh836.tistory.com/112)

[빨간색코딩]

# 하지만 아주 가끔씩 factor형 변형이 안될경우도 있다! 그런경우는 케릭터로 변경후 다시 변경

#문자형이 아니고 factor형이다..?

#순서
#ordered(obj, levels=변수값, labels=요인이름)
AgeG <- c(4,2,3,2,1,3,2,4)
age.ord <- ordered(AgeG,labels=c("20대 이하","30대","40대","50대 이상"))
age.ord

**!참고문헌**

[32](https://data-make.tistory.com/32)

# ▶ 벡터에서 자료를 삽입하고 삭제와 관련된 다양한 함수들을 살펴본다.

# 벡터 접근

vec1 <- c(1,2,3,4,5) #1~5까지 자료를 갖는 vec1 변수 생성
vec1[2] #두 번째 자료
vec1[c(2,3,5)] #vec1의 2, 3, 5의 값만 표현
vec1[c(-2,-3)] #vec1의 2, 3번째 자료 값 빼고 갖고와줘.
vec1[2] <- 6 #두 번째 위치의 2값이 6으로 대체됨

length(vec1)
vec1[1:3]
rm(list = ls()) #오브젝트 내의 모든 변수 삭제

##########################################

### 1-4 데이터 구조 형태(메트릭스)

##########################################

### 행렬(Matrix)

# 

# ▶ 행렬(matrix)은 동일한 형으로 구성된 2차원의 데이터 구조이다

# ▶ 행의 차원과 열의 차원을 갖는 행렬은 수학에서의 행렬과는 달리 문자형이나 논리형 등을 원소로 사용할 수 있다.

# ▶ 그러나 행렬의 원소는 한가지 형의 자료만 허락됨

#행렬(matrix)은 여러 변수들이 이차원적으로 모여 있는 개체로,
#행렬을 생성하기 위해서는 matrix() 함수를 사용
#matrix() 함수 이외에 cbind(), rbind(), dim() 등을 이용하여 행렬을 생성시킬 수 있음

matrix(1:9, nrow=3) #nrow : 행의 개수 지정
matrix(c(1,4,7,2,5,8,3,6,9), byrow=T, ncol=3) #ncol : 열의 개수 지정 byrow=T : 행 기준 행렬을 생성

matrix(c(1,4,7,
2,5,8,
3,6,9), byrow=T, ncol=3) #ncol : 열의 개수 지정 byrow=T : 행 기준 행렬을 생성

rm(list = ls()) #오브젝트 내의 모든 변수 삭제

# 벡터에 차원을 결정해줘서 생성 가능

m1 <- 1:9
#dim : 차원을 연결.그냥 dim(m1)하면 NUL
dim(m1) <- c(3,3)
m1

#행렬과 관련된 여러 함수와 성분의 추출과 삭제 등에 관해 알아봄
mat <- matrix(c(1,2,3,4,5,6,7,8,9), ncol=3, byrow=T) #행 기준 3열의 행렬 생성
mat[1,] #행렬 mat의 1행의 값
mat[,3] #행렬 mat의 3열의 값
mat[1,2]

mat[1,1]

a = matrix(c(1:9),ncol=3,byrow=T)
a

rownames(mat) <- c("a1","a2","a3")
mat
colnames(mat) <- c("z1","z2","z3")
mat

dim(mat) # 행 열 확인하기

rm(list = ls()) #오브젝트 내의 모든 변수 삭제

a=seq(1,3,length=5)

#seq(1,3,0.5)
A=rep(a, times=1:5)
A

B=1:15
B

matrix(c(B,A), byrow=T, ncol=5)

colnames(M) = paste0("col1",1:5)
#paste0 특정 문자나 문자, 숫자나 숫자, 등을 조합을 만들어 합쳐주는.

rep(b, times=c(1,2,3,4,5))
a
##########################################

### 1-5 데이터 구조 형태(배열)

##########################################

### 배열(Array)

# 

# ▶ 배열(Array)은 행렬을 2차원 이상으로 확장시킨 객체로써 2차원의 구조를 갖는 행렬도 배열의 한 종류이다.

# ▶ 그러나 일반적으로 3차원 이상의 차원을 갖는 데이터 객체를 배열이라고 부름

# ▶ 배열을 생성하기 위해서는 array 함수를 사용한다.

#배열의 속성 : 행렬의 속성과 같이 자료의 개수를 나타내는 length, 형태를 보여주는 mode,
#각 차원의 벡터의 크기를 나타내는 dim 그리고 각 차원의 리스트 이름을 나타내는 dimnames로 구성

#배열의 생성
#배열을 생성하기 위한 함수로 array() 함수와 dim() 함수가 있음
array(1:6) #1~6의 자료로 1차원 배열 생성
array(1:6, c(2,3)) #1~6의 자료로 2차원 배열 생성
array(1:8, c(2,2,2)) #1~8의 자료로 3차원 배열 생성
arr <- c(1:24) #1~24의 자료 생성
dim(arr) <- c(3,4,2) #dim() 함수를 이용하여 3행 4열의 행렬 2개 생성
arr

rm(list = ls()) #오브젝트 내의 모든 변수 삭제

[38](https://data-make.tistory.com/38)

##########################################

### 1-6 데이터 구조 형태(데이터 프레임)

##########################################

### week 데이터 프레임(data.frame)

# 

# ▶ 데이터 프레임은 행렬과 비슷한 형태로 되어 있으나,

# 행렬은 차원으로 표시되며 같은 형태(mode)의 객체를 가지는 반면,

# 데이터 프레임은 각 열(column)들이 서로 다른 형태(mode)의 객체를 가질 수 있으므로

# 범주형 변수를 가질 수도 있기 때문에 범주형 자료분석에도 유용하게 사용된다.

#data.frame() : 이미 생성되어 있는 벡터들을 결합하여 데이터 프레임을 생성
char1 <- rep(LETTERS[1:3],c(2,2,1)) #벡터 / letters: 대문자 영어 합친 / 반복할거야. 2번, 2번, 1번
char1
num1 <- rep(1:3,c(2,2,1)) #벡터
num1
test1 <- data.frame(char1, num1) #test1 데이터 프레임 생성
test1 = data.frame(a=char1, b=num1)
test1
#바로 변수명 할당이 가능하다.
#열기준으로.

#as.data.frame() :모든 다른 종류의 자료객체들을 데이터 프레임으로 변환
mat <- matrix(c(1,2,3,4,5,6,7,8,9), ncol=3, byrow=T) #행 기준 3열의 행렬 생성
mat
test3 <- as.data.frame(mat) #a1을 데이터 프레임으로 변환
test3
#데이터프레임으로 변환하면, 이름에 넣어주는거야. / 변수기준으로.
#as를 안 써도 덮어 씌워주기는 합니다.

test3 <- data.frame(mat)
test3

rm(list = ls()) #오브젝트 내의 모든 변수 삭제

##########################################

### 1-7 데이터 구조 형태(리스트)

##########################################

### 리스트(list) #### 도서관

# 

# ▶ 리스트(List)는 서로 다른 형태(mode)의 자료를 포함하는 하나의 객체이다.

# ▶ 리스트를 생성하기 위해서는 list 함수를 사용한다.

li <- list("top", c(2,4,6),c(T,F,T)) #list(문자, 숫자(백터), 논리형 객체)
#3차원이라는게 아니라 각 층에 보관.
li[[1]] #[[1]]:첫 번째 성분

mat1 <- matrix(1:4, nrow=2)
mat1
list1 <- list("A", 1:8, mat1)
list1

#[son.name](http://son.name/) 이름 할당.
son <- list([son.name](http://son.name/) = c("Minsu", "Minchul"), son.cnt = 2, son.age = c(2.6))
son

#리스트 속성 : 벡터의 속성과 같이 자료의 개수, 형태, 구성요소의 이름 등을 보여주는 length, mode, names로 구성
length(son) #son 리스트 자료의 개수 (층의갯수)
mode(son) #son 리스트 자료의 형태
names(son) #son 리스트 각 구성요소의 이름

rm(list = ls()) #오브젝트 내의 모든 변수 삭제

#예제
exm <- list(c("Abe", "Bob", "Carol", "Deb"),c("Weight","Waist")) #exm의 이름으로 list생성
exm[[2]] #리스트의 2번째 성분
exm[[2]][2] #2번째 성분 2번째 원소
names(exm) <- c("Rows","Columns") #exm 리스트에 성분 이름 부여

exm$Rows #exm의 Rows 성분만 표현
exm[[1]]
exm$Rows[2] #Rows 성분 2번째 원소 표현
exm$Columns #exm의 Columns 성분만 표현

rm(list = ls()) #오브젝트 내의 모든 변수 삭제
